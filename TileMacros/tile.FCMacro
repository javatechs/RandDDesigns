__Name__ = 'Tile'
__Comment__ = 'Creates a tile model in your doc if open.'
__Author__ = ''
__Version__ = '0.0.1'
__Date__ = '2021-12-06'
__License__ = 'GNU GENERAL PUBLIC LICENSE'
__Web__ = ''
__Wiki__ = ''
__Icon__ = 'icon.png'
__Help__ = ''
__Status__ = 'Alpha'
__Requires__ = 'FreeCAD >= v0.19 with Assembly 4 Workbench Installed.'
__Communication__ = ''
__Files__ = ''

'''
    Create Tile Macro
    Description:
    Creates a tile with user entered dimensions and feature parameters.

    Approach:
    If no document, spreadsheet and assembly 
    If this is an assembly document, add to tile to parts
'''
import FreeCAD as App
import FreeCADGui as Gui

from PySide import QtGui
import Part
import PartDesign
import PartDesignGui
import Sketcher
#from shapely.geometry.polygon import orient

# Make module accessible
sys.path.append(os.path.dirname( __file__ ))
#import tileHelper as th
#ex = th.Example()

# Local macro variables
docName  = "Unnamed"
tileName = "tile"

# Defaults for user entered values
unitWidth = 4
unitLength = 3
tileWidth = 10*unitWidth
tileLength = 10*unitLength
#
slotDepth   = 5.0
m3InsertDia = 4.85
insertDia   = m3InsertDia
thruMountHole = True

class tile:

    def __init__(self):
        self.docObj = None
        self.theParts = None
        self.partBody = None
        self.lcs = None
        self.extendedEdge = False
    '''
    FreeCAD organizes models in files called documents.
    If an active document exists, select that for use
    If not, create a the new assembly doc with spreadsheet
    '''
    def createOrGetDoc(self, inpDocName):
        # Is there an active document?
        if App.ActiveDocument==None:
            # No. Create one.
            App.newDocument(inpDocName)
            # Create spreadsheet for parameters
            Gui.activateWorkbench("SpreadsheetWorkbench")
            App.activeDocument().addObject('Spreadsheet::Sheet','Spreadsheet')
            #Create an assembly
            Gui.activateWorkbench("Assembly4Workbench")
            Gui.runCommand('Asm4_makeAssembly',0)

        # Get the Doc name
        docName = App.ActiveDocument.Label
        # Get document object
        self.docObj = App.ActiveDocument
        # If we have a 'Parts' group, select it
        self.theParts = self.docObj.getObject('Parts')

        # Now let's go to Part Design
        Gui.activateWorkbench("PartDesignWorkbench")
        Gui.Selection.clearSelection()


    ''' 
    Create a Part and Body object for model container
    ''' 
    def createPart(self, name):
        newTile = App.activeDocument().addObject('App::Part',name)
        # Get the name of the new tile.
        # If Part named Tile already exists, append counting number.
        name = newTile.Label
        App.activeDocument().Tip = newTile
        # Get tile object
        tileObj = self.docObj.getObject(name)

        # Select Parts, if we have an assembly
        if self.theParts is not None:
            tileObj.adjustRelativeLinks(self.theParts)
            self.theParts.addObject(tileObj)

        # Select newly created part
        Gui.Selection.clearSelection()
        Gui.Selection.addSelection(tileObj)
        Gui.ActiveDocument.ActiveView.setActiveObject('part', tileObj)

        # Add LCS object
        self.lcs = tileObj.newObject('PartDesign::CoordinateSystem','LCS_'+name)
        self.lcs.MapMode = 'ObjectXY'
        self.lcs.Support = newTile.Origin.OriginFeatures[0]

        # Create  a body for this part
        Gui.ActiveDocument.ActiveView.setActiveObject('part', tileObj)
        self.partBody = App.activeDocument().addObject('PartDesign::Body',name+'_body')

        # Move '<name>_body' to Part '<name>'
        tileObj.addObject(self.partBody)
        Gui.Selection.addSelection(self.partBody)
        # Actual name assigned by FC
        return name

    ''' 
    Create a basic tile as a body object container
    ''' 
    def createObject_Tile(self, name):
        # Create tile sketch
        sketchObj = App.ActiveDocument.addObject("Sketcher::SketchObject", name+"_skt")
        self.partBody.addObject(sketchObj)
        sketchObj.MapMode='FlatFace'
        sketchObj.Visibility = False

        # OriginFeatures[3] is the xy plane
        sketchObj.Support = self.partBody.Origin.OriginFeatures[3]

        # Draw tile and extrude
        geoList = []
        thw=tileWidth/2
        thl=tileLength/2
        # Create line segments
        p1 = App.Vector(-thw,thl,0)
        p2 = App.Vector(thw ,thl,0)
        p3 = App.Vector(thw ,-thl,0)
        p4 = App.Vector(-thw,-thl,0)
        geoList.append(Part.LineSegment(p1,p2))
        geoList.append(Part.LineSegment(p2,p3))
        geoList.append(Part.LineSegment(p3,p4))
        geoList.append(Part.LineSegment(p4,p1))

        sketchObj.addGeometry(geoList,False)

        conList = []
        #Sketcher.Constraint('Coincident',LineFixed,PointOfLineFixed,LineMoving,PointOfLineMoving)
        conList.append(Sketcher.Constraint('Coincident',0,2,1,1))
        conList.append(Sketcher.Constraint('Coincident',1,2,2,1))
        conList.append(Sketcher.Constraint('Coincident',2,2,3,1))
        conList.append(Sketcher.Constraint('Coincident',3,2,0,1))
        conList.append(Sketcher.Constraint('Symmetric',0,1,1,2,-1,1)) 
        conList.append(Sketcher.Constraint('Symmetric',0,2,2,2,-1,1)) 

        # tileLength
        conList.append(Sketcher.Constraint('DistanceY',3,1,3,2,tileLength)) 

        # tileWidth
        conList.append(Sketcher.Constraint('DistanceX',0,1,0,2,tileWidth)) 

        conList.append(Sketcher.Constraint('Horizontal',0))
        conList.append(Sketcher.Constraint('Vertical',1))
        sketchObj.addConstraint(conList)

        padObj = self.partBody.newObject('PartDesign::Pad',name+'_obj')
        padObj.Profile = sketchObj
        padObj.Length = 4.0


    '''
    Create Mount Hole object.
    Mount holes are open from the side typically used for outside.
    Mount holes are through all if 'thruMountHole==True'.
    Diameter is controlled by insertDia.
    Hole is centered 10mm from 2 intersecting edges perpendicular from the plane.
    '''
    def createObject_MountHole(self, name):
        # Hole Sketch
        thw=tileWidth/2
        thl=tileLength/2

        #sketchObj = App.ActiveDocument.addObject("Sketcher::SketchObject", "Sketch")
        sketchObj = self.docObj.addObject("Sketcher::SketchObject", name+"_skt")
        self.partBody.addObject(sketchObj)
        sketchObj.MapMode='FlatFace'
        # OriginFeatures[3] is the xy plane
        sketchObj.Support = self.partBody.Origin.OriginFeatures[3]
        sketchObj.Visibility=False

        geoList = []
        g1=sketchObj.addGeometry(Part.Circle(App.Vector(0,0,0), App.Vector(0,0,1), insertDia/2), False)
        sketchObj.addConstraint(Sketcher.Constraint('Diameter',0,insertDia))
        # Horz & Vert: 
        # tileWidth / 2 - 10
        # tileLength / 2 - 10
        sketchObj.addConstraint(Sketcher.Constraint('DistanceX', -1, 1, g1, 3, -(thw-10)))
        sketchObj.addConstraint(Sketcher.Constraint('DistanceY', -1, 1, g1, 3, thl-10))
        # Pocket
        pocket = self.partBody.newObject('PartDesign::Pocket', name+'_obj')
        pocket.Profile = sketchObj
        # 3.5 + (thruMountHole ? 0 : 1)
        len = 3.5
        if thruMountHole==True:
        	len+=1
        pocket.Length = len 
        pocket.Reversed = 1
        pocket.Visibility=True
        return pocket, sketchObj


    '''
    Create a 2D array of Mount Hole objects.
    '''
    def createObject_MountHoleArray(self, name, pocket, sketchObj):
        multiTransform = self.partBody.newObject('PartDesign::MultiTransform',name)
        multiTransform.Originals = [pocket,]
        holePatV = self.partBody.newObject('PartDesign::LinearPattern', name+'_vert_pattern')
        holePatV.Direction = (sketchObj,['V_Axis'])
        # tileLength - 20 < 1 ? 1 : tileLength - 20
        len = tileLength - 20
        if tileLength - 20 < 1:
            len=1 
        holePatV.Length = len
        holePatV.Occurrences = unitLength - 1
        holePatV.Reversed = 1

        holePatH = self.partBody.newObject('PartDesign::LinearPattern',name+'_horz_pattern')
        holePatH.Direction = (sketchObj,['H_Axis'])
        # tileWidth - 20 < 1 ? 1 : tileWidth - 20
        len = tileWidth - 20
        if tileWidth - 20 < 1:
        	len=1 
        holePatH.Length = len
        holePatH.Occurrences = unitWidth - 1
        #holePatH.Reversed = 1
        multiTransform.Transformations = [holePatV,holePatH]
        multiTransform.Visibility=True
        return multiTransform


    ''' 
    Verticle Slot or Key Body

       1/| 
    > 0| |2 'Slot diagram'
       3\|

    >           = Points to x,y midpoint. 
                  Example diagram opens 'E'ast orientation 
    x           = horz mid pt small end
    y           = vert mid pt small end
    orient      = 'N'orth, 'S'outh, 'E'ast, 'W'est
    '''

    def createObject_SlotKey(self, name, afterObj, xorg, yorg, orient, key):
        ## Create new sketch
        sketchObj = App.ActiveDocument.addObject("Sketcher::SketchObject", name+"_skt")
        self.partBody.insertObject(sketchObj, afterObj, True)
        sketchObj.MapMode='FlatFace'
        sketchObj.Visibility=False

        # OriginFeatures[3] is the XY plane
        sketchObj.Support = self.partBody.Origin.OriginFeatures[3]

        if orient=='U':
            # OriginFeatures[5] is the YZ plane
            sketchObj.Support = self.partBody.Origin.OriginFeatures[5]

        # Slot sizes
        narrow = 4/2
        wide = 7/2
        depth = 5
        if key:
            # Key sizes
            narrow = 3.6/2
            wide = 6.6/2
            depth = 4.85
        # See https://github.com/ebrahimraeyat/Civil/blob/5d25dfd47aae8f310b9e73ab780889cfb31e278a/safe/punch/axis.py
        geoList = []
        # Create line segments
        # p4 <- p3
        # p1 -> p2 /\
        # TODO Is key/slot being drawn in the same order no matter orientation?
        if orient=='E':
            p1=App.Vector(xorg      , yorg-narrow, 0.0)
            p2=App.Vector(xorg      , yorg+narrow, 0.0)
            p3=App.Vector(xorg+depth, yorg+wide  , 0.0)
            p4=App.Vector(xorg+depth, yorg-wide  , 0.0)
        elif orient=='W':
            p1=App.Vector(xorg      , yorg-narrow, 0.0)
            p2=App.Vector(xorg      , yorg+narrow, 0.0)
            p3=App.Vector(xorg-depth, yorg+wide  , 0.0)
            p4=App.Vector(xorg-depth, yorg-wide  , 0.0)
        else:
            p1=App.Vector(xorg-narrow, yorg      , 0.0)
            p2=App.Vector(xorg+narrow, yorg      , 0.0)
            p3=App.Vector(xorg+wide  , yorg+depth, 0.0)
            p4=App.Vector(xorg-wide  , yorg+depth, 0.0)

        geoList.append(Part.LineSegment(p1,p2))
        geoList.append(Part.LineSegment(p2,p3))
        geoList.append(Part.LineSegment(p3,p4))
        geoList.append(Part.LineSegment(p4,p1))
        sketchObj.addGeometry(geoList,False)

        # Constraints
        conList = []

        #Sketcher.Constraint('Coincident',LineFixed,PointOfLineFixed,LineMoving,PointOfLineMoving)
        conList.append(Sketcher.Constraint('Coincident',0,2,1,1))
        conList.append(Sketcher.Constraint('Coincident',1,2,2,1))
        conList.append(Sketcher.Constraint('Coincident',2,2,3,1))
        conList.append(Sketcher.Constraint('Coincident',3,2,0,1))
        # 
        if orient == 'E':
            conList.append(Sketcher.Constraint('DistanceX',0,1,2,2,depth))
        elif orient == 'W':
            conList.append(Sketcher.Constraint('DistanceX',1,2,0,2,depth)) 

        if orient in ('E','W'):
            conList.append(Sketcher.Constraint('Vertical',0))
            conList.append(Sketcher.Constraint('Vertical',2))
            conList.append(Sketcher.Constraint('DistanceY',0,1,0,2,narrow*2))
            conList.append(Sketcher.Constraint('DistanceY',2,2,2,1,wide*2))
            conList.append(Sketcher.Constraint('DistanceY',0,2,1,2,wide-narrow)) 
        else:
            conList.append(Sketcher.Constraint('Horizontal',0))
            conList.append(Sketcher.Constraint('Horizontal',2))
            conList.append(Sketcher.Constraint('DistanceX',0,1,0,2,narrow*2))
            conList.append(Sketcher.Constraint('DistanceX',2,2,2,1,wide*2))
            conList.append(Sketcher.Constraint('DistanceX',0,2,1,2,wide-narrow)) 
            conList.append(Sketcher.Constraint('DistanceY',0,1,2,2,depth))
        sketchObj.addConstraint(conList)
        '''
        # Fillet. See:
        # https://freecad.github.io/SourceDoc/d9/dad/classSketcher_1_1SketchObject.html#a43c1d2127f6883712935706a98e1cf4a
        ## sketchObj.fillet(0,1,App.Vector(0.0,0.5,0),App.Vector(0.5,0.0,0),0.5,True,True)
        ## sketchObj.fillet(1,2,App.Vector(0.0,0.5,0),App.Vector(0.5,0.0,0),0.5,True,True)
        '''
        # If key
        if key:
            # Key
            pocket = self.partBody.newObject('PartDesign::Pad',name+'_obj')
            len = 3.5
            pocket.Reversed = 0
        else:
            # Slot
            pocket = self.partBody.newObject('PartDesign::Pocket',name+' obj')
            len = 3.5
            pocket.Reversed = 1
        pocket.Profile = sketchObj
        pocket.Length = len 
        pocket.Visibility=True
        self.partBody.removeObject(pocket)
        self.partBody.insertObject(pocket, afterObj, True)
        return pocket, sketchObj

    '''
    Using the slot object, create a linear array.
    Parameters:
    name:            Name of sketch/object
    inputObject:     Object to be 'arrayed'. 
                     Also serves as last object
    sketchObject:    Used for object orientation
    orient           One of 'S', 'U' or other.
    '''
    def createObject_SlotKeyArray(self, name, inputObject, sketchObj, orient):
        multiTransform = self.partBody.newObject('PartDesign::MultiTransform', name)
        multiTransform.Originals = [inputObject,]
        holePatV = self.partBody.newObject('PartDesign::LinearPattern', name+'_LinearPattern')

        holePatV.Direction = (sketchObj,['V_Axis'])
        dim = tileLength
        unit = unitLength
        if orient == 'S':
            holePatV.Direction = (sketchObj,['H_Axis'])
            dim = tileWidth
            unit = unitWidth
        elif orient=='U':
            holePatV.Direction = (sketchObj,['H_Axis'])
            dim = tileLength
            unit = unitLength
        # len - 20 < 1 ? 1 : len - 20
        len = dim - 20
        if dim - 20 < 1:
            len=1 
        holePatV.Length = len
        holePatV.Occurrences = unit - 1
        holePatV.Reversed = 0

        multiTransform.Transformations = [holePatV]
        self.partBody.removeObject(multiTransform)
        self.partBody.insertObject(multiTransform, inputObject, True)
        
        return multiTransform
    '''
    Using the input slot or key object, create a linear and then polar array.
    '''
    def createObject_SlotKeyArrayPolar(self, name, inputObject, sketchObj, orient):
        multiTransform = self.createObject_SlotKeyArray(name, inputObject, sketchObj, orient)

        polar = self.partBody.newObject('PartDesign::PolarPattern',name+'_PolarPattern')
        polar.Axis = (sketchObj,['N_Axis'])
        polar.Angle = 360
        polar.Occurrences = 2
        polar.Visibility = False

        multiTransform.Transformations = [multiTransform.Transformations[0],polar]
        self.partBody.removeObject(multiTransform)
        self.partBody.insertObject(multiTransform, inputObject, True)
        
        return multiTransform

    '''
    Connector tunnel
    '''
    def createObject_Connector(self, name, afterObj, orient, key):

        ## Create new sketch
        sketchObj = App.ActiveDocument.addObject("Sketcher::SketchObject", name+"_skt")
        self.partBody.insertObject(sketchObj, afterObj, True)
        sketchObj.MapMode='FlatFace'
        # OriginFeatures[4] is the XZ plane
        sketchObj.Support = self.partBody.Origin.OriginFeatures[4]
        len = tileLength
        wid = tileWidth
        if orient == 'S':
            # OriginFeatures[5] is the YZ plane
            sketchObj.Support = self.partBody.Origin.OriginFeatures[5]
            len = tileWidth
            wid = tileLength
        sketchObj.Visibility=False

        # See https://github.com/ebrahimraeyat/Civil/blob/5d25dfd47aae8f310b9e73ab780889cfb31e278a/safe/punch/axis.py
        geoList = []
        # Create line segments
        # Height = 2mm
        # Width = 4mm
        # Length = tileLength - 18
        p1=App.Vector(-wid/2  ,0,0)
        p2=App.Vector(-wid/2  ,2,0)
        p3=App.Vector(-wid/2+2,2,0)
        p4=App.Vector(-wid/2+2,0,0)
        if orient == 'W':
            p3=App.Vector(-wid/2-2,2,0)
            p4=App.Vector(-wid/2-2,0,0)
        geoList.append(Part.LineSegment(p1,p2))
        geoList.append(Part.LineSegment(p2,p3))
        geoList.append(Part.LineSegment(p3,p4))
        geoList.append(Part.LineSegment(p4,p1))
        sketchObj.addGeometry(geoList,False)

        # Constraints
        conList = []

        #Sketcher.Constraint('Coincident',LineFixed,PointOfLineFixed,LineMoving,PointOfLineMoving)
        conList.append(Sketcher.Constraint('Coincident',0,2,1,1))
        conList.append(Sketcher.Constraint('Coincident',1,2,2,1))
        conList.append(Sketcher.Constraint('Coincident',2,2,3,1))
        conList.append(Sketcher.Constraint('Coincident',3,2,0,1))
#         conList.append(Sketcher.Constraint('DistanceX',1,1,1,2,2.000000))
#         conList.append(Sketcher.Constraint('DistanceY',2,2,2,1,2.000000))
        conList.append(Sketcher.Constraint('Vertical',0))
        conList.append(Sketcher.Constraint('Horizontal',1))
        conList.append(Sketcher.Constraint('Vertical',2))
        conList.append(Sketcher.Constraint('Horizontal',3))
        sketchObj.addConstraint(conList)

        ## Pad(key=True) or Pocket(slot)
        if key:
            pocket = self.partBody.newObject('PartDesign::Pad', name+'_obj')
        else:
            pocket = self.partBody.newObject('PartDesign::Pocket', name+'_obj')
        pocket.Profile = sketchObj

        pocket.Length = len - 18
        pocket.Reversed = 0
        pocket.Midplane = 1
        pocket.Visibility=True
        self.partBody.removeObject(pocket)
        self.partBody.insertObject(pocket, afterObj, True)
        return pocket, sketchObj

    '''
    Latch 
    '''
    def createObject_Latch(self, name, afterObj, orient):
        ## Create new sketch
        sketchObj = App.ActiveDocument.addObject("Sketcher::SketchObject", name + "_skt")
        self.partBody.insertObject(sketchObj, afterObj, True)
        sketchObj.MapMode='FlatFace'
        # OriginFeatures[4] is the XZ plane
        sketchObj.Support = self.partBody.Origin.OriginFeatures[4]
        len = tileLength
        wid = tileWidth
        if orient != 'E':
            # OriginFeatures[5] is the YZ plane
            sketchObj.Support = self.partBody.Origin.OriginFeatures[5]
            len = tileWidth
            wid = tileLength
        sketchObj.Visibility=False

        # See https://github.com/ebrahimraeyat/Civil/blob/5d25dfd47aae8f310b9e73ab780889cfb31e278a/safe/punch/axis.py
        geoList = []
        # Create line segments
        # Length = tileLength - 12
        # Describe a 4 sided object with vertices a,b,c,d
        # d <- c
        # a -> b /\
        xwid = 0.6              # Width = 0.6 mm
        y1 = 0.5                # Height = 0.5 mm or
        y2 = 0.8                # Height = 0.8 mm
        xorg = wid/2 - slotDepth    # Start for x
        p1=App.Vector(xorg     , 0.0, 0.0)
        p2=App.Vector(xorg+xwid, 0.0, 0.0)
        p3=App.Vector(xorg+xwid,  y1, 0.0)
        p4=App.Vector(xorg     ,  y2, 0.0)
        geoList.append(Part.LineSegment(p1,p2))
        geoList.append(Part.LineSegment(p2,p3))
        geoList.append(Part.LineSegment(p3,p4))
        geoList.append(Part.LineSegment(p4,p1))
        sketchObj.addGeometry(geoList,False)

        # Constraints
        conList = []

        #Sketcher.Constraint('Coincident',LineFixed,PointOfLineFixed,LineMoving,PointOfLineMoving)
        conList.append(Sketcher.Constraint('Coincident',0,2,1,1))
        conList.append(Sketcher.Constraint('Coincident',1,2,2,1))
        conList.append(Sketcher.Constraint('Coincident',2,2,3,1))
        conList.append(Sketcher.Constraint('Coincident',3,2,0,1))
        conList.append(Sketcher.Constraint('Horizontal',0))
        conList.append(Sketcher.Constraint('Vertical',1))
        conList.append(Sketcher.Constraint('Vertical',3))
        conList.append(Sketcher.Constraint('DistanceX',0,1,0,2,xwid))
        conList.append(Sketcher.Constraint('DistanceY',1,1,1,2,y1))
        conList.append(Sketcher.Constraint('DistanceY',3,2,3,1,y2))

        sketchObj.addConstraint(conList)

        # Latch object (Pad)
        newObj = self.partBody.newObject('PartDesign::Pad', name+'_obj')
        newObj.Profile = sketchObj

        newObj.Length = len - 12
        newObj.Reversed = 0
        newObj.Midplane = 1
        newObj.Visibility=True
        # Insert in the correct place
        self.partBody.removeObject(newObj)
        self.partBody.insertObject(newObj, afterObj, True)
        return newObj, sketchObj

    '''
    Latch notch, accepts the latch and locks.
    '''
    def createObject_LatchNotch(self, name, afterObj, orient):
        ## Create new sketch
        sketchObj = App.ActiveDocument.addObject("Sketcher::SketchObject", name + "_skt")
        self.partBody.insertObject(sketchObj, afterObj, True)
        sketchObj.MapMode='FlatFace'
        # OriginFeatures[4] is the XZ plane
        sketchObj.Support = self.partBody.Origin.OriginFeatures[4]
        sketchObj.Visibility=False
        len = tileLength
        wid = tileWidth

        # Snip shape
        xwid = 0.7
        xorg = -wid/2+5
        y1=0.9
        y2=0.55
        if orient == 'W':
            xorg = -wid/2-5
            xwid = -0.7
        p1=App.Vector(xorg     , y1 ,0)
        p2=App.Vector(xorg-xwid, y2,0)
        p3=App.Vector(xorg-xwid, 0.0 ,0)
        p4=App.Vector(xorg     , 0.0 ,0)
        if orient == 'U':
            xorg = xorg-9
            p1=App.Vector(xorg+y1, 10,0)
            p2=App.Vector(xorg+y2,  8,0)
            p3=App.Vector(xorg   ,  8,0)
            p4=App.Vector(xorg   , 10,0)
        geoList = []
        geoList.append(Part.LineSegment(p1,p2))
        geoList.append(Part.LineSegment(p2,p3))
        geoList.append(Part.LineSegment(p3,p4))
        geoList.append(Part.LineSegment(p4,p1))
        sketchObj.addGeometry(geoList,False)

        # Constraints
        conList = []

        #Sketcher.Constraint('Coincident',LineFixed,PointOfLineFixed,LineMoving,PointOfLineMoving)
        conList.append(Sketcher.Constraint('Coincident',0,2,1,1))
        conList.append(Sketcher.Constraint('Coincident',1,2,2,1))
        conList.append(Sketcher.Constraint('Coincident',2,2,3,1))
        conList.append(Sketcher.Constraint('Coincident',3,2,0,1))
        if orient != 'U':
            conList.append(Sketcher.Constraint('Vertical',1))
            conList.append(Sketcher.Constraint('Horizontal',2))
            conList.append(Sketcher.Constraint('Vertical',3))
            conList.append(Sketcher.Constraint('DistanceY',1,2,1,1,y2))
            conList.append(Sketcher.Constraint('DistanceX',2,1,2,2,xwid))
            conList.append(Sketcher.Constraint('DistanceY',3,1,3,2,y1))
        sketchObj.addConstraint(conList)

        # Notch (pocket)
        newObj = self.partBody.newObject('PartDesign::Pocket', name+'_obj')
        newObj.Profile = sketchObj

        newObj.Length = len
        newObj.Reversed = 0
        newObj.Midplane = 1
        newObj.Visibility=False
        # Insert in the correct place
        self.partBody.removeObject(newObj)
        self.partBody.insertObject(newObj, afterObj, True)
        return newObj, sketchObj
    '''
    Create connector latch then a polar array from the connector.
    '''
    def createObject_ConnectorLatchArray(self, name, afterObj, sketchObj, connectorArray, latchArray):
        multiTransform = self.partBody.newObject('PartDesign::MultiTransform', name)
        multiTransform.Originals = [connectorArray, latchArray,]

        polar = self.partBody.newObject('PartDesign::PolarPattern',name+'_PolarPattern')
        polar.Axis = (sketchObj,['V_Axis'])
        polar.Angle = 360
        polar.Occurrences = 2
        polar.Visibility = False

        multiTransform.Transformations = [polar]
        self.partBody.removeObject(multiTransform)
        self.partBody.insertObject(multiTransform, afterObj, True)
        # Insert in the correct place
        self.partBody.removeObject(multiTransform)
        self.partBody.insertObject(multiTransform, afterObj, True)
        
        return multiTransform

    '''
    Bracket supports the 90deg   
    '''
    def createObject_BracketBacker(self, name, afterObj, orient):
        sketchObj = App.ActiveDocument.addObject("Sketcher::SketchObject", name+"_skt")
        self.partBody.insertObject(sketchObj, afterObj, True)
        sketchObj.MapMode='FlatFace'
        # OriginFeatures[4] is the XZ plane
        sketchObj.Support = self.partBody.Origin.OriginFeatures[4]
        len = tileLength
        wid = tileWidth
        geoList = []
        # A drawing in 8 points!
        p1=App.Vector(-wid/2-5  , 9.5,0)
        p2=App.Vector(-wid/2-4  , 9.5,0)
        p3=App.Vector(-wid/2-4  , 4,0)
        p4=App.Vector(-wid/2    , 4,0)
        p5=App.Vector(-wid/2    , 0,0)
        p6=App.Vector(-wid/2+5.5, 0,0)
        p7=App.Vector(-wid/2+5.5,-1,0)
        p8=App.Vector(-wid/2-5  ,-1,0)
        geoList.append(Part.LineSegment(p1,p2))
        geoList.append(Part.LineSegment(p2,p3))
        geoList.append(Part.LineSegment(p3,p4))
        geoList.append(Part.LineSegment(p4,p5))
        geoList.append(Part.LineSegment(p5,p6))
        geoList.append(Part.LineSegment(p6,p7))
        geoList.append(Part.LineSegment(p7,p8))
        geoList.append(Part.LineSegment(p8,p1))
        sketchObj.addGeometry(geoList,False)
        sketchObj.Visibility = False

        # Constraints
        conList = []

        #Sketcher.Constraint('Coincident',LineFixed,PointOfLineFixed,LineMoving,PointOfLineMoving)
        conList.append(Sketcher.Constraint('Coincident',0,2,1,1))
        conList.append(Sketcher.Constraint('Coincident',1,2,2,1))
        conList.append(Sketcher.Constraint('Coincident',2,2,3,1))
        conList.append(Sketcher.Constraint('Coincident',3,2,4,1))
        conList.append(Sketcher.Constraint('Coincident',4,2,5,1))
        conList.append(Sketcher.Constraint('Coincident',5,2,6,1))
        conList.append(Sketcher.Constraint('Coincident',6,2,7,1))
        conList.append(Sketcher.Constraint('Coincident',7,2,0,1))
        #
        conList.append(Sketcher.Constraint('DistanceX',6,2,6,1,10.500000))
        conList.append(Sketcher.Constraint('DistanceY',7,1,7,2,10.500000))
        conList.append(Sketcher.Constraint('DistanceX',2,1,2,2,4.000000))
        conList.append(Sketcher.Constraint('DistanceY',3,2,3,1,4.000000)) 
        conList.append(Sketcher.Constraint('DistanceY',1,2,1,1,5.500000))
        conList.append(Sketcher.Constraint('DistanceX',4,1,4,2,5.500000))
        #
        conList.append(Sketcher.Constraint('Horizontal',0))
        conList.append(Sketcher.Constraint('Vertical',1))
        conList.append(Sketcher.Constraint('Horizontal',2))
        conList.append(Sketcher.Constraint('Vertical',3))
        conList.append(Sketcher.Constraint('Horizontal',4))
        conList.append(Sketcher.Constraint('Vertical',5))
        conList.append(Sketcher.Constraint('Horizontal',6))
        conList.append(Sketcher.Constraint('Vertical',7))
        sketchObj.addConstraint(conList)
        #
        pad = self.partBody.newObject('PartDesign::Pad', name+'_obj')
        pad.Profile = sketchObj


        if self.extendedEdge:
            len -=0.1
        else:
            len -=10
        pad.Length = len
        pad.Midplane = 1
        pad.Visibility = True
        self.partBody.removeObject(pad)
        self.partBody.insertObject(pad, afterObj, True)
        return pad, sketchObj

    '''
    Hinge body. Accepts pin.
    Contains pivot point.
    '''
    def createObject_HingeBody(self, name, afterObj, orient):
        sketchObj = App.ActiveDocument.addObject("Sketcher::SketchObject", name+"_skt")
        self.partBody.insertObject(sketchObj, afterObj, True)
        sketchObj.MapMode='FlatFace'
        sketchObj.Visibility = False

        # OriginFeatures[4] is the XZ plane
        sketchObj.Support = self.partBody.Origin.OriginFeatures[4]
        len = tileLength
        wid = tileWidth
        geoList = []
        # A drawing in 8 points!
        p1=App.Vector(-wid/2-4  , 4.0,0)
        p2=App.Vector(-wid/2    , 4.0,0)
        p3=App.Vector(-wid/2    , 0.0,0)
        p4=App.Vector(-wid/2+5  , 0.0,0)
        p5=App.Vector(-wid/2+5  ,-1.0,0)
        p6=App.Vector(-wid/2-4  ,-1.0,0)

        geoList.append(Part.LineSegment(p1,p2))
        geoList.append(Part.LineSegment(p2,p3))
        geoList.append(Part.LineSegment(p3,p4))
        geoList.append(Part.LineSegment(p4,p5))
        geoList.append(Part.LineSegment(p5,p6))
        geoList.append(Part.LineSegment(p6,p1))
        sketchObj.addGeometry(geoList,False)

        conList = []
        #Sketcher.Constraint('Coincident',LineFixed,PointOfLineFixed,LineMoving,PointOfLineMoving)
        conList.append(Sketcher.Constraint('Coincident',0,2,1,1))
        conList.append(Sketcher.Constraint('Coincident',1,2,2,1))
        conList.append(Sketcher.Constraint('Coincident',2,2,3,1))
        conList.append(Sketcher.Constraint('Coincident',3,2,4,1))
        conList.append(Sketcher.Constraint('Coincident',4,2,5,1))
        conList.append(Sketcher.Constraint('Coincident',5,2,0,1))
        conList.append(Sketcher.Constraint('DistanceX',1,2,-1,1,wid/2))
        conList.append(Sketcher.Constraint('DistanceX',0,1,0,2,4.000000))
        conList.append(Sketcher.Constraint('DistanceX',4,2,4,1,9.000000))
        conList.append(Sketcher.Constraint('DistanceY',1,2,1,1,4.000000))
        conList.append(Sketcher.Constraint('DistanceY',5,1,5,2,5.000000))
        conList.append(Sketcher.Constraint('DistanceY',-1,1,2,2,0.000000))
        conList.append(Sketcher.Constraint('Horizontal',0))
        conList.append(Sketcher.Constraint('Horizontal',2))
        conList.append(Sketcher.Constraint('Horizontal',4))
        conList.append(Sketcher.Constraint('Vertical',1))
        conList.append(Sketcher.Constraint('Vertical',3))
        conList.append(Sketcher.Constraint('Vertical',5))
        sketchObj.addConstraint(conList)

        # Add hinge pin hole
        radius=1.92/2
        Xvar=-wid/2-2
        Yvar=2
        sketchObj.addGeometry(Part.Circle(App.Vector(Xvar,Yvar,0),App.Vector(0,0,1),radius),False)
        sketchObj.addConstraint(Sketcher.Constraint('DistanceY',6,3,0,2,2.000000))
        sketchObj.addConstraint(Sketcher.Constraint('DistanceX',6,3,0,2,2.000000))
        sketchObj.addConstraint(Sketcher.Constraint('Radius',6,radius))

        # 
        # TODO Compute X & Y vector values
        sketchObj.fillet(3,4,App.Vector(-15.0,-0.5,0),App.Vector(-16.0,-1.0,0),0.5,True,True)
        sketchObj.addConstraint(Sketcher.Constraint('Radius',7,0.500000))
        sketchObj.fillet(4,5,App.Vector(-23.5,-1.0,0),App.Vector(-24.0,-0.5,0),0.5,True,True)
        sketchObj.addConstraint(Sketcher.Constraint('Radius',9,0.500000))
        sketchObj.fillet(5,0,App.Vector(-24.0,3,0),App.Vector(-23.5,4,0),2.0,True,True)
        sketchObj.addConstraint(Sketcher.Constraint('Radius',11,2.0))

        # Object
        pad = self.partBody.newObject('PartDesign::Pad',name+'_obj')
        pad.Profile = sketchObj

        # len = tileWidth - (extendedEdge==True? 0.2 : 10)
        if self.extendedEdge:
            len -=0.2
        else:
            len -=10
        pad.Length = len
        pad.Midplane = 1
        pad.Visibility = True
        self.partBody.removeObject(pad)
        self.partBody.insertObject(pad, afterObj, True)
        return pad, sketchObj

    '''
    Hinge mating cut and array
    '''
    def createObject_HingeMateCut(self, name, afterObj, orient):
        sketchObj = App.ActiveDocument.addObject("Sketcher::SketchObject", name+"_skt")
        self.partBody.insertObject(sketchObj, afterObj, True)
        sketchObj.MapMode='FlatFace'
        sketchObj.Visibility = False

        # OriginFeatures[4] is the XZ plane
        sketchObj.Support = self.partBody.Origin.OriginFeatures[4]
        len = tileLength
        wid = tileWidth
        geoList = []

        # Snip shape
        p1=App.Vector(-wid/2-4  , 4.0,0)
        p2=App.Vector(-wid/2    , 4.0,0)
        p3=App.Vector(-wid/2    ,-1.0,0)
        p4=App.Vector(-wid/2-4  ,-1.0,0)

        geoList.append(Part.LineSegment(p1,p2))
        geoList.append(Part.LineSegment(p2,p3))
        geoList.append(Part.LineSegment(p3,p4))
        geoList.append(Part.LineSegment(p4,p1))
        sketchObj.addGeometry(geoList,False)

        # Constraints
        conList = []

        #Sketcher.Constraint('Coincident',LineFixed,PointOfLineFixed,LineMoving,PointOfLineMoving)
        conList.append(Sketcher.Constraint('Coincident',0,2,1,1))
        conList.append(Sketcher.Constraint('Coincident',1,2,2,1))
        conList.append(Sketcher.Constraint('Coincident',2,2,3,1))
        conList.append(Sketcher.Constraint('Coincident',3,2,0,1))
        conList.append(Sketcher.Constraint('Horizontal',0))
        conList.append(Sketcher.Constraint('Vertical',1)) 
        conList.append(Sketcher.Constraint('Horizontal',2))
        conList.append(Sketcher.Constraint('Vertical',3))
        conList.append(Sketcher.Constraint('DistanceX',0,1,0,2,4.000000))
        conList.append(Sketcher.Constraint('DistanceY',3,1,3,2,5.000000)) 
        sketchObj.addConstraint(conList)

        # Object
        newObj = self.partBody.newObject('PartDesign::Pocket',name+'_obj')
        newObj.Profile = sketchObj
        # TODO Save cut
        newObj.Length = 5.30
        newObj.Midplane = 0
        newObj.Visibility = False
        self.partBody.removeObject(newObj)
        self.partBody.insertObject(newObj, afterObj, True)

        # Array
        multiTransform = self.partBody.newObject('PartDesign::MultiTransform', name+'_array')
        multiTransform.Originals = [newObj,]
        holePatV = self.partBody.newObject('PartDesign::LinearPattern',name+'_LinearPattern')
        holePatV.Direction = (sketchObj,['N_Axis'])
        holePatV.Length = tileWidth-10
        holePatV.Occurrences = unitWidth
        holePatV.Reversed = 0

        multiTransform.Transformations = [holePatV]
        self.partBody.removeObject(multiTransform)
        self.partBody.insertObject(multiTransform, newObj, True)
        
        return multiTransform, sketchObj

    '''
    Latch 
    '''
    def refreshScreen(self, lastObj):
        App.activeDocument().recompute()
        Gui.Selection.clearSelection()
        lastObj.Visibility=True
        Gui.Selection.addSelection(lastObj)
        Gui.Selection.clearSelection()
        Gui.activeDocument().activeView().viewIsometric()
        Gui.SendMsgToActiveView("ViewFit")

    '''
    Part: Tile
    '''
    def doTile(self):
        self.createOrGetDoc(docName)
        self.createPart(tileName)

        # Create Body and tile object
        self.createObject_Tile('tile_base')
        # Object: Mount Hole
        (pocket, sketchObj) = self.createObject_MountHole("tile_mount_hole")
        # Object: Mount Hole Array
        lastObj = self.createObject_MountHoleArray('tile_mount_array', pocket, sketchObj)

        # V E R T I C A L
        thw=tileWidth/2
        thl=tileLength/2
        # Object: Vert, East facing slot
        (pocket, sketchObj) = self.createObject_SlotKey("tile_vert_slot", lastObj,-thw,-thl+10,'E', False)
        # Object: Vert Slot and Polar Array
        lastObj = self.createObject_SlotKeyArrayPolar('tile_vert_slot_array', pocket, sketchObj,'E')
        # Object: Vert Slot Connector
        (connectorArray, sketchObj) = self.createObject_Connector('tile_vspine_slot', lastObj, 'E', False)
        # Object: Vert Latch
        (latchArray, sketchObj) = self.createObject_Latch('tile_vert_latch', connectorArray, 'E')
        # Object: Vert Slot Connector and Latch Polar Array
        lastObj = self.createObject_ConnectorLatchArray('tile_vert_latch array', latchArray, sketchObj, connectorArray, latchArray)
 
        # H O R I Z O N T A L
        # Object: Horz, South facing Slot
        (pocket, sketchObj) = self.createObject_SlotKey("tile_horz_slot", lastObj,-thw+10,-thl,'S', False)
        # Object: Horz Slot and Polar Array
        lastObj = self.createObject_SlotKeyArrayPolar('tile_horz_slot_array', pocket, sketchObj,'S')
        # Object: Horz Slot Connector
        (connectorArray, sketchObj) = self.createObject_Connector('tile_hspine_slot', lastObj, 'S', False)
        # Object: Horz Latch
        (latchArray, sketchObj) = self.createObject_Latch('tile_horz_latch', connectorArray, 'S')
        # Object: Vert Slot Connector and Latch Polar Array
        lastObj = self.createObject_ConnectorLatchArray('tile_horz_latch_array', latchArray, sketchObj, connectorArray, latchArray)
 
        # REFRESH SCREEN!
        self.refreshScreen(lastObj)

    '''
    Part: Connector
    '''
    def doConnector(self):
        thw=tileWidth/2
        thl=tileLength/2

        self.createOrGetDoc(docName)
        partName = self.createPart("connector")
        # Reset LCS
        self.lcs.AttachmentOffset = App.Placement(App.Vector(-thw,0,0),App.Rotation(App.Vector(0,0,1),0))

        lastObj=None
        # Side 1
        # Obj: Key spine
        (lastObj, sketchObj) = self.createObject_Connector('rspine', lastObj, 'E', True)
        # Obj: Key
        (lastObj, sketchObj) = self.createObject_SlotKey("rspine_key", lastObj,-thw,-thl+10,'E', True)
        # Obj: Key Array
        lastObj = self.createObject_SlotKeyArray('rspine_key_array', lastObj, sketchObj,'E')
        # Obj: Latch Notch
        (lastObj, sketchObj) = self.createObject_LatchNotch('rspine_latch_notch', lastObj, 'E')

        # Side 2
        # Obj: Key Connector
        (lastObj, sketchObj) = self.createObject_Connector('lspine', lastObj, 'W', True)
        # Obj: Key
        (lastObj, sketchObj) = self.createObject_SlotKey("lspine_key", lastObj,-thw,-thl+10,'W', True)
        # Obj: Key Array
        lastObj = self.createObject_SlotKeyArray('lspine_key_array', lastObj, sketchObj,'W')
        # Obj: Latch Notch
        (lastObj, sketchObj) = self.createObject_LatchNotch('lspine_latch_notch', lastObj, 'W')

        # REFRESH SCREEN!
        self.refreshScreen(lastObj)

    '''
    Part: Bracket
    '''
    def doBracket(self):
        thw=tileWidth/2
        thl=tileLength/2

        self.createOrGetDoc(docName)
        partName = self.createPart("bracket")
        # Reset LCS
        self.lcs.AttachmentOffset = App.Placement(App.Vector(-thw,0,0),App.Rotation(App.Vector(0,0,1),0))

        lastObj=None
        # Side 1
        # Obj: Key Spine
        (connector, sketchObj) = self.createObject_Connector('bracket_lwr_spine', lastObj, 'E', True)
        lastObj=connector
        # Obj: Key
        (pad, sketchObj) = self.createObject_SlotKey("bracket_lwr_key", lastObj,-thw,-thl+10,'E', True)
        lastObj=pad
        # Obj: Key Array
        lastObj = self.createObject_SlotKeyArray('bracket_lwr_key_array', pad, sketchObj,'E')
        # Obj: Latch Notch
        (lastObj, sketchObj) = self.createObject_LatchNotch('bracket_lwr_latch_notch', lastObj, 'E')

        (lastObj, sketchObj) = self.createObject_BracketBacker("bracket_backer", lastObj, 'E')

        # Side 2
#         # Obj: Key Connector
#         (connector, sketchObj) = self.createObject_Connector('bracket_bk_spine', lastObj, 'U', True)
#         lastObj=connector
        # Obj: Key
        (pad, sketchObj) = self.createObject_SlotKey("bracket_bk_key", lastObj,-thw+15, 4, 'U', True)
#         sketchObj.Placement.Base=App.Vector(15,9,-24)
        sketchObj.AttachmentOffset = App.Placement(App.Vector(0,0,-24),App.Rotation(App.Vector(0,0,1),0))
        # Obj: Key Array
        lastObj = self.createObject_SlotKeyArray('bracket_bk_key_array', pad, sketchObj,'U')
        # Obj: Latch Notch
        (lastObj, sketchObj) = self.createObject_LatchNotch('bracket_bk_latch_notch', lastObj, 'U')
 
        # REFRESH SCREEN!
        self.refreshScreen(lastObj)


    '''
    Part: Hinge
    '''
    def doHinge(self):
        thw=tileWidth/2
        thl=tileLength/2

        self.createOrGetDoc(docName)
        partName = self.createPart("hinge")
        # Reset LCS
        self.lcs.AttachmentOffset = App.Placement(App.Vector(-thw,0,0),App.Rotation(App.Vector(0,0,1),0))

        lastObj=None
        # Key & spine
        # Object: Key Spine
        (lastObj, sketchObj) = self.createObject_Connector('hinge_key_spine', lastObj, 'E', True)
        # Object: Key
        (lastObj, sketchObj) = self.createObject_SlotKey("hinge_key", lastObj,-thw,-thl+10,'E', True)
        # Object: Key Array
        lastObj = self.createObject_SlotKeyArray('hinge_key_array', lastObj, sketchObj,'E')

        # Object: Hinge frame
        (lastObj, sketchObj) = self.createObject_HingeBody('hinge_frame', lastObj, 'E')
        # Obj: Mate cut (pocket) and array
        (lastObj, sketchObj) = self.createObject_HingeMateCut('hinge_mate_cut', lastObj, 'E')
        # Obj: Latch Notch
        (lastObj, sketchObj) = self.createObject_LatchNotch('hinge_latch_notch', lastObj, 'E')
        # REFRESH SCREEN!
        self.refreshScreen(lastObj)

### END OF CLASS tile ###

#
# Create Tile Object
#

#X TODO: Finish basic implementation
#X TODO: Add lcs to tile for assembly

## TODO: Add fillet to slot corners
## TODO: Add lcs to bracket, hinge and connector for assembly
## TODO: Query user for dimensions
## TODO: Add constraints

# Instantiate tile object
_tile = tile()
# Model a tile
_tile.doTile()
_tile.doConnector()
_tile.doBracket()
# _tile.doHinge()
