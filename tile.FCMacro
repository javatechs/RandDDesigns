__Name__ = 'Tile Generator Macro'
__Comment__ = 'Creates a tile model parts in your doc, if open. Create new doc if necessary.'
__Author__ = ''
__Version__ = '0.0.1'
__Date__ = '2021-12-06'
__License__ = 'GNU GENERAL PUBLIC LICENSE'
__Web__ = ''
__Wiki__ = ''
__Icon__ = 'icon.png'
__Help__ = ''
__Status__ = 'Alpha'
__Requires__ = 'FreeCAD >= v0.19 with Assembly 4 Workbench Installed.'
__Communication__ = ''
__Files__ = 'tile.FCMacro'

'''
    Tile Generator Macro
    Description:
    Creates a tile connector, bracket or hinge with 
    user entered dimensions and feature parameters.

    Approach:
    If no document, spreadsheet and assembly 
    If this is an assembly document, add to tile to parts
'''
import FreeCAD as App
import FreeCADGui as Gui

from PySide import QtCore, QtGui
import Part
import PartDesign
import PartDesignGui
import Sketcher

# Local macro variables
docName  = "Unnamed"
tileName = "tile"

#
slotDepth   = 5.0
m3InsertDia = 4.85
insertDia   = m3InsertDia

class widget(QtGui.QWidget):
    def keyPressEvent(self, event):
        key = event.key()
        if key ==  QtCore.Qt.Key_Escape:
            self.hide()
        else:
            super().keyPressEvent(event) 

class Ui_Dialog(object):

    def __init__(self):
        self.d = None

    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(280, 340)
        self.title = QtGui.QLabel(Dialog)
        self.title.setGeometry(QtCore.QRect(10, 10, 260, 30))
        self.title.setObjectName("title")
        self.label_width = QtGui.QLabel(Dialog)
        self.label_width.setGeometry(QtCore.QRect(30, 60, 57, 16))
        self.label_width.setObjectName("label_width")
        self.label_length = QtGui.QLabel(Dialog)
        self.label_length.setGeometry(QtCore.QRect(30, 90, 57, 16))
        self.label_length.setObjectName("label_length")
        self.width = QtGui.QLineEdit(Dialog)
        self.width.setGeometry(QtCore.QRect(100, 52, 60, 26))
        self.width.setObjectName("width")
        self.length = QtGui.QLineEdit(Dialog)
        self.length.setGeometry(QtCore.QRect(100, 82, 60, 26))
        self.length.setObjectName("length")
        #
        self.label_hole = QtGui.QLabel(Dialog)
        self.label_hole.setGeometry(QtCore.QRect(30, 120, 90, 16))
        self.label_hole.setObjectName("label_hole")
        self.throughHole = QtGui.QCheckBox(Dialog)
        self.throughHole.setGeometry(QtCore.QRect(140, 116, 60, 26))
        self.throughHole.setChecked(True)

        self.label_extend = QtGui.QLabel(Dialog)
        self.label_extend.setGeometry(QtCore.QRect(30, 140, 90, 16))
        self.label_extend.setObjectName("label_extend")
        self.extendedEdge = QtGui.QCheckBox(Dialog)
        self.extendedEdge.setGeometry(QtCore.QRect(140, 136, 60, 26))
        self.extendedEdge.setChecked(False)

        self.label_create = QtGui.QLabel(Dialog)
        self.label_create.setGeometry(QtCore.QRect(30, 170, 80, 16))
        self.label_create.setObjectName("label_create")
        #
        width=80
        self.createTile = QtGui.QPushButton(Dialog)
        self.createTile.setGeometry(QtCore.QRect(30, 190, width, 26))
        self.createTile.setObjectName("create_tile")
        self.createHinge = QtGui.QPushButton(Dialog)
        self.createHinge.setGeometry(QtCore.QRect(120, 190, width, 26))
        self.createHinge.setObjectName("create_hinge")
        self.createConnector = QtGui.QPushButton(Dialog)
        self.createConnector.setGeometry(QtCore.QRect(30, 220, width, 26))
        self.createConnector.setObjectName("create_connector")
        self.createBracket = QtGui.QPushButton(Dialog)
        self.createBracket.setGeometry(QtCore.QRect(120, 220, width, 26))
        self.createBracket.setObjectName("create_bracket")
        self.cancel = QtGui.QPushButton(Dialog)
        self.cancel.setGeometry(QtCore.QRect(30, 270, 160, 26))
        self.cancel.setObjectName("cancel")

        self.retranslateUi(Dialog)
        QtCore.QObject.connect(self.createTile,QtCore.SIGNAL("pressed()"),self.createPartTile)
        QtCore.QObject.connect(self.createConnector,QtCore.SIGNAL("pressed()"),self.createPartConnector)
        QtCore.QObject.connect(self.createHinge,QtCore.SIGNAL("pressed()"),self.createPartHinge)
        QtCore.QObject.connect(self.createBracket,QtCore.SIGNAL("pressed()"),self.createPartBracket)
        QtCore.QObject.connect(self.cancel,QtCore.SIGNAL("pressed()"),self.d.hide)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        Dialog.setWindowTitle("Dialog")
        self.title.setText("Tile Generator Macro\n(Use whole centimeters. Minimum of 2.)")
#         self.title.setStyleSheet("background-color: lightblue")
        self.title.setStyleSheet("background-color: yellow; border: 1px solid black;")
        self.label_width.setText("Width")
        self.label_length.setText("Length *")
        self.label_hole.setText("Through hole")
        self.label_extend.setText("Extend edge")
        self.label_create.setText("Create Part...")
        self.createTile.setText("&Tile")
        self.createConnector.setText("&Connector")
        self.createHinge.setText("&Hinge")
        self.createBracket.setText("&Bracket")
        self.cancel.setText("Cancel")

    def getValues(self, part):
        part.thruMountHole = self.throughHole.isChecked()

        self.getLenValue(part)
        try:
            msg = 'Error! Width must be a valid integer number > 1!'
            # check whether valid numbers have been entered
            w = int(self.width.text())
            if w<2:
                msg = 'Error! Width must be > 1!'
                raise ValueError
        except ValueError:
            self.errorDialog(msg)
        else:
            part.unitWidth = w
            return True
        return False

    def getLenValue(self, part):
        try:
            msg = 'Error! Length value must a valid integer number > 1!'
            # check whether valid numbers have been entered
            l = int(self.length.text())
            if l<2:
                msg = 'Error! Length must be > 1!'
                raise ValueError
        except ValueError:
            self.errorDialog(msg)
        else:
            part.unitLength = l
            return True
        return False

    def errorDialog(self, msg):
        # Create a simple dialog QMessageBox
        # The first argument indicates the icon used: one of QtGui.QMessageBox.{NoIcon, Information, Warning, Critical, Question} 
        diag = QtGui.QMessageBox(QtGui.QMessageBox.Warning, 'Error in macro MessageBox', msg)
        diag.setWindowModality(QtCore.Qt.ApplicationModal)
        diag.exec_()

    def createPartTile(self):
        _tile = tile()
        if self.getValues(_tile):
            self.d.hide()
            _tile.doTile()

    def createPartConnector(self):
        _tile = tile()
        if self.getLenValue(_tile):
            self.d.hide()
            _tile.doConnector()

    def createPartBracket(self):
        _tile = tile()
        if self.getLenValue(_tile):
            self.d.hide()
            _tile.doBracket()

    def createPartHinge(self):
        _tile = tile()
        if self.getValues(_tile):
            self.d.hide()
            _tile.doHinge()

class operateUI():
    def __init__(self):
##         self.d = QtGui.QWidget()
#         self.d = widget()
#         self.ui = Ui_Dialog()
#         self.ui.d = self.d
#         self.ui.setupUi(self.d)
#         self.d.setWindowModality(QtCore.Qt.ApplicationModal)
#         self.d.show()
        d = widget()
        self.ui = Ui_Dialog()
        self.ui.d = d
        self.ui.setupUi(d)
        d.setWindowModality(QtCore.Qt.ApplicationModal)
        d.show()

'''

'''
class tile:

    def __init__(self):
        self.docObj = None
        self.theParts = None
        self.partBody = None
        self.lcs = None
        self.extendedEdge = False
        #
        self.slot_narrow = 4
        self.slot_wide = 7
        self.slot_depth = 5
        self.slot_height = 3.5

        self.key_narrow = 3.6
        self.key_wide = 6.6
        self.key_depth = 4.85
        self.key_height = 3.4
        
        self.radius = 0.5

        # Defaults for user entered values
        self.thruMountHole = True
        self.unitWidth = 4
        self.unitLength = 3
        self.tileWidth = 10*self.unitWidth
        self.tileLength = 10*self.unitLength
        # Extend outer edge to limits? 1=yes; 0=no
        self.extendedEdge = False

    def calcTileSize(self):
        self.tileWidth = 10*self.unitWidth
        self.tileLength = 10*self.unitLength

    '''
    FreeCAD organizes models in files called documents.
    If an active document exists, select that for use
    If not, create a the new assembly doc with spreadsheet
    '''
    def createOrGetDoc(self, inpDocName):
        # Is there an active document?
        if App.ActiveDocument==None:
            # No. Create one.
            App.newDocument(inpDocName)
            # Create spreadsheet for parameters
            Gui.activateWorkbench("SpreadsheetWorkbench")
            App.activeDocument().addObject('Spreadsheet::Sheet','Spreadsheet')
            #Create an assembly
            Gui.activateWorkbench("Assembly4Workbench")
            Gui.runCommand('Asm4_makeAssembly',0)

        # Get the Doc name
        docName = App.ActiveDocument.Label
        # Get document object
        self.docObj = App.ActiveDocument
        # If we have a 'Parts' group, select it
        self.theParts = self.docObj.getObject('Parts')

        # Now let's go to Part Design
        Gui.activateWorkbench("PartDesignWorkbench")
        Gui.Selection.clearSelection()


    ''' 
    Create a Part and Body object for model container
    ''' 
    def createPart(self, name):
        self.calcTileSize()
        newTile = App.activeDocument().addObject('App::Part',name)
        # Get the name of the new tile.
        # If Part named Tile already exists, append counting number.
        name = newTile.Label
        App.activeDocument().Tip = newTile
        # Get tile object
        tileObj = self.docObj.getObject(name)

        # Select Parts, if we have an assembly
        if self.theParts is not None:
            tileObj.adjustRelativeLinks(self.theParts)
            self.theParts.addObject(tileObj)

        # Select newly created part
        Gui.Selection.clearSelection()
        Gui.Selection.addSelection(tileObj)
        Gui.ActiveDocument.ActiveView.setActiveObject('part', tileObj)

        # Add LCS object
        self.lcs = tileObj.newObject('PartDesign::CoordinateSystem','LCS_'+name)
        self.lcs.MapMode = 'ObjectXY'
        self.lcs.Support = newTile.Origin.OriginFeatures[0]

        # Create  a body for this part
        Gui.ActiveDocument.ActiveView.setActiveObject('part', tileObj)
        self.partBody = App.activeDocument().addObject('PartDesign::Body',name+'_body')

        # Move '<name>_body' to Part '<name>'
        tileObj.addObject(self.partBody)
        Gui.Selection.addSelection(self.partBody)
        # Actual name assigned by FC
        return name

    ''' 
    Create a basic tile as a body object container
    ''' 
    def createObject_Tile(self, name):
        # Create tile sketch
        sketchObj = App.ActiveDocument.addObject("Sketcher::SketchObject", name+"_skt")
        self.partBody.addObject(sketchObj)
        sketchObj.MapMode='FlatFace'
        sketchObj.Visibility = False

        # OriginFeatures[3] is the xy plane
        sketchObj.Support = self.partBody.Origin.OriginFeatures[3]

        # Draw tile and extrude
        geoList = []
        thw=self.tileWidth/2
        thl=self.tileLength/2
        # Create line segments
        p1 = App.Vector(-thw,thl,0)
        p2 = App.Vector(thw ,thl,0)
        p3 = App.Vector(thw ,-thl,0)
        p4 = App.Vector(-thw,-thl,0)
        geoList.append(Part.LineSegment(p1,p2))
        geoList.append(Part.LineSegment(p2,p3))
        geoList.append(Part.LineSegment(p3,p4))
        geoList.append(Part.LineSegment(p4,p1))

        sketchObj.addGeometry(geoList,False)

        conList = []
        #Sketcher.Constraint('Coincident',LineFixed,PointOfLineFixed,LineMoving,PointOfLineMoving)
        conList.append(Sketcher.Constraint('Coincident',0,2,1,1))
        conList.append(Sketcher.Constraint('Coincident',1,2,2,1))
        conList.append(Sketcher.Constraint('Coincident',2,2,3,1))
        conList.append(Sketcher.Constraint('Coincident',3,2,0,1))
        conList.append(Sketcher.Constraint('Symmetric',0,1,1,2,-1,1)) 
        conList.append(Sketcher.Constraint('Symmetric',0,2,2,2,-1,1)) 

        # tileLength
        conList.append(Sketcher.Constraint('DistanceY',3,1,3,2,self.tileLength)) 

        # tileWidth
        conList.append(Sketcher.Constraint('DistanceX',0,1,0,2,self.tileWidth)) 

        conList.append(Sketcher.Constraint('Horizontal',0))
        conList.append(Sketcher.Constraint('Vertical',1))
        sketchObj.addConstraint(conList)

        padObj = self.partBody.newObject('PartDesign::Pad',name+'_obj')
        padObj.Profile = sketchObj
        padObj.Length = 4.0


    '''
    Create Mount Hole object.
    Mount holes are open from the side typically used for outside.
    Mount holes are through all if 'thruMountHole==True'.
    Diameter is controlled by insertDia.
    Hole is centered 10mm from 2 intersecting edges perpendicular from the plane.
    '''
    def createObject_MountHole(self, name):
        # Hole Sketch
        thw=self.tileWidth/2
        thl=self.tileLength/2

        #sketchObj = App.ActiveDocument.addObject("Sketcher::SketchObject", "Sketch")
        sketchObj = self.docObj.addObject("Sketcher::SketchObject", name+"_skt")
        self.partBody.addObject(sketchObj)
        sketchObj.MapMode='FlatFace'
        # OriginFeatures[3] is the xy plane
        sketchObj.Support = self.partBody.Origin.OriginFeatures[3]
        sketchObj.Visibility=False

        geoList = []
        g1=sketchObj.addGeometry(Part.Circle(App.Vector(0,0,0), App.Vector(0,0,1), insertDia/2), False)
        sketchObj.addConstraint(Sketcher.Constraint('Diameter',0,insertDia))
        # Horz & Vert: 
        # tileWidth / 2 - 10
        # tileLength / 2 - 10
        sketchObj.addConstraint(Sketcher.Constraint('DistanceX', -1, 1, g1, 3, -(thw-10)))
        sketchObj.addConstraint(Sketcher.Constraint('DistanceY', -1, 1, g1, 3, thl-10))
        # Pocket
        pocket = self.partBody.newObject('PartDesign::Pocket', name+'_obj')
        pocket.Profile = sketchObj
        # 3.5 + (thruMountHole ? 0 : 1)
        len = 3.5
        if self.thruMountHole==True:
        	len+=1
        pocket.Length = len 
        pocket.Reversed = 1
        pocket.Visibility=True
        return pocket, sketchObj


    '''
    Create a 2D array of Mount Hole objects.
    '''
    def createObject_MountHoleArray(self, name, pocket, sketchObj):
        multiTransform = self.partBody.newObject('PartDesign::MultiTransform',name)
        multiTransform.Originals = [pocket,]
        holePatV = self.partBody.newObject('PartDesign::LinearPattern', name+'_vert_pattern')
        holePatV.Direction = (sketchObj,['V_Axis'])
        # tileLength - 20 < 1 ? 1 : tileLength - 20
        len = self.tileLength - 20
        if self.tileLength - 20 < 1:
            len=1 
        holePatV.Length = len
        holePatV.Occurrences = self.unitLength - 1
        holePatV.Reversed = 1

        holePatH = self.partBody.newObject('PartDesign::LinearPattern',name+'_horz_pattern')
        holePatH.Direction = (sketchObj,['H_Axis'])
        # tileWidth - 20 < 1 ? 1 : tileWidth - 20
        len = self.tileWidth - 20
        if self.tileWidth - 20 < 1:
        	len=1 
        holePatH.Length = len
        holePatH.Occurrences = self.unitWidth - 1
        #holePatH.Reversed = 1
        multiTransform.Transformations = [holePatV,holePatH]
        multiTransform.Visibility=True
        return multiTransform


    ''' 
    Verticle Slot or Key Body

       1/| 
    > 0| |2 'Slot diagram'
       3\|

    >           = Points to x,y midpoint. 
                  Example diagram opens 'E'ast orientation 
    x           = horz mid pt small end
    y           = vert mid pt small end
    orient      = 'N'orth, 'S'outh, 'E'ast, 'W'est
    '''

    def createObject_SlotKey(self, name, afterObj, xorg, yorg, orient, key):
        ## Create new sketch
        sketchObj = App.ActiveDocument.addObject("Sketcher::SketchObject", name+"_skt")
        self.partBody.insertObject(sketchObj, afterObj, True)
        sketchObj.MapMode='FlatFace'
        sketchObj.Visibility=False

        # OriginFeatures[3] is the XY plane
        sketchObj.Support = self.partBody.Origin.OriginFeatures[3]

        if orient=='U':
            # OriginFeatures[5] is the YZ plane
            sketchObj.Support = self.partBody.Origin.OriginFeatures[5]
            sketchObj.AttachmentOffset = App.Placement(App.Vector(0,0,-(self.tileWidth/2)-4),App.Rotation(App.Vector(0,0,1),0))
        # Slot sizes
        narrow = self.slot_narrow/2
        wide = self.slot_wide/2
        depth = self.slot_depth
        height = self.slot_height
        if key:
            # Key sizes
            narrow = self.key_narrow/2
            wide = self.key_wide/2
            depth = self.key_depth
            height = self.key_height

        # See https://github.com/ebrahimraeyat/Civil/blob/5d25dfd47aae8f310b9e73ab780889cfb31e278a/safe/punch/axis.py
        geoList = []
        # Create line segments
        # p4 <- p3
        # p1 -> p2 /\
        # TODO Is key/slot being drawn in the same order no matter orientation?
        if orient=='E':
            p1=App.Vector(xorg      , yorg-narrow, 0.0)
            p2=App.Vector(xorg      , yorg+narrow, 0.0)
            p3=App.Vector(xorg+depth, yorg+wide  , 0.0)
            p4=App.Vector(xorg+depth, yorg-wide  , 0.0)
            p5=Part.Point(App.Vector(xorg+depth, yorg,0))
        elif orient=='W':
            p1=App.Vector(xorg      , yorg-narrow, 0.0)
            p2=App.Vector(xorg      , yorg+narrow, 0.0)
            p3=App.Vector(xorg-depth, yorg+wide  , 0.0)
            p4=App.Vector(xorg-depth, yorg-wide  , 0.0)
            p5=Part.Point(App.Vector(xorg-depth, yorg,0))
        else:
            p1=App.Vector(xorg-narrow, yorg      , 0.0)
            p2=App.Vector(xorg+narrow, yorg      , 0.0)
            p3=App.Vector(xorg+wide  , yorg+depth, 0.0)
            p4=App.Vector(xorg-wide  , yorg+depth, 0.0)
            p5=Part.Point(App.Vector(xorg, yorg+depth,0))

        geoList.append(Part.LineSegment(p1,p2))
        geoList.append(Part.LineSegment(p2,p3))
        geoList.append(Part.LineSegment(p3,p4))
        geoList.append(Part.LineSegment(p4,p1))
        geoList.append(p5)
        sketchObj.addGeometry(geoList,False)

        # Constraints
        conList = []

        #Sketcher.Constraint('Coincident',LineFixed,PointOfLineFixed,LineMoving,PointOfLineMoving)
        conList.append(Sketcher.Constraint('Coincident',0,2,1,1))
        conList.append(Sketcher.Constraint('Coincident',1,2,2,1))
        conList.append(Sketcher.Constraint('Coincident',2,2,3,1))
        conList.append(Sketcher.Constraint('Coincident',3,2,0,1))
        # 
        if orient == 'E':
            conList.append(Sketcher.Constraint('DistanceX',0,1,2,2,depth))
        elif orient == 'W':
            conList.append(Sketcher.Constraint('DistanceX',1,2,0,2,depth)) 

        if orient in ('E','W'):
            conList.append(Sketcher.Constraint('Vertical',0))
            conList.append(Sketcher.Constraint('Vertical',2))
            conList.append(Sketcher.Constraint('DistanceY',0,1,0,2,narrow*2))
            conList.append(Sketcher.Constraint('DistanceY',2,2,2,1,wide*2))
            conList.append(Sketcher.Constraint('DistanceY',0,2,1,2,wide-narrow)) 
        else:
            conList.append(Sketcher.Constraint('Horizontal',0))
            conList.append(Sketcher.Constraint('Horizontal',2))
            conList.append(Sketcher.Constraint('DistanceX',0,1,0,2,narrow*2))
            conList.append(Sketcher.Constraint('DistanceX',2,2,2,1,wide*2))
            conList.append(Sketcher.Constraint('DistanceX',0,2,1,2,wide-narrow)) 
            conList.append(Sketcher.Constraint('DistanceY',0,1,2,2,depth))
        sketchObj.addConstraint(conList)
        '''
        # Fillet. See:
        # https://freecad.github.io/SourceDoc/d9/dad/classSketcher_1_1SketchObject.html#a43c1d2127f6883712935706a98e1cf4a
        ## sketchObj.fillet(0,1,App.Vector(0.0,0.5,0),App.Vector(0.5,0.0,0),0.5,True,True)
        ## sketchObj.fillet(1,2,App.Vector(0.0,0.5,0),App.Vector(0.5,0.0,0),0.5,True,True)
        '''
        # If key
        if key:
            # Key
            pocket = self.partBody.newObject('PartDesign::Pad',name+'_obj')
            len = self.key_height
            pocket.Reversed = 0
        else:
            # Slot
            pocket = self.partBody.newObject('PartDesign::Pocket',name+' obj')
            len = self.slot_height
            pocket.Reversed = 1
        pocket.Profile = sketchObj
        pocket.Length = len 
        pocket.Visibility=True
        self.partBody.removeObject(pocket)
        self.partBody.insertObject(pocket, afterObj, True)

        return pocket, sketchObj

    '''
    Using the slot object, create a linear array.
    Parameters:
    name:            Name of sketch/object
    inputObject:     Object to be 'arrayed'. 
                     Also serves as last object
    sketchObject:    Used for object orientation
    orient           One of 'S', 'U' or other.
    '''
    def createObject_SlotKeyArray(self, name, inputObject, list, sketchObj, orient):
        multiTransform = self.partBody.newObject('PartDesign::MultiTransform', name)
        multiTransform.Originals = list
        holePatV = self.partBody.newObject('PartDesign::LinearPattern', name+'_LinearPattern')

        holePatV.Direction = (sketchObj,['V_Axis'])
        dim = self.tileLength
        unit = self.unitLength
        if orient == 'S':
            holePatV.Direction = (sketchObj,['H_Axis'])
            dim = self.tileWidth
            unit = self.unitWidth
        elif orient=='U':
            holePatV.Direction = (sketchObj,['H_Axis'])
            dim = self.tileLength
            unit = self.unitLength
        # len - 20 < 1 ? 1 : len - 20
        len = dim - 20
        if dim - 20 < 1:
            len=1 
        holePatV.Length = len
        holePatV.Occurrences = unit - 1
        holePatV.Reversed = 0

        multiTransform.Transformations = [holePatV]
        self.partBody.removeObject(multiTransform)
        self.partBody.insertObject(multiTransform, inputObject, True)
        
        return multiTransform
    '''
    Using the input slot or key object, create a linear and then polar array.
    '''
    def createObject_SlotKeyArrayPolar(self, name, inputObject, list, sketchObj, orient):
        multiTransform = self.createObject_SlotKeyArray(name, inputObject, list, sketchObj, orient)

        polar = self.partBody.newObject('PartDesign::PolarPattern',name+'_PolarPattern')
        polar.Axis = (sketchObj,['N_Axis'])
        polar.Angle = 360
        polar.Occurrences = 2
        polar.Visibility = False

        multiTransform.Transformations = [multiTransform.Transformations[0],polar]
        self.partBody.removeObject(multiTransform)
        self.partBody.insertObject(multiTransform, inputObject, True)
        
        return multiTransform

    '''
    Connector tunnel
    '''
    def createObject_Connector(self, name, afterObj, orient, key):

        ## Create new sketch
        sketchObj = App.ActiveDocument.addObject("Sketcher::SketchObject", name+"_skt")
        self.partBody.insertObject(sketchObj, afterObj, True)
        sketchObj.MapMode='FlatFace'
        # OriginFeatures[4] is the XZ plane
        sketchObj.Support = self.partBody.Origin.OriginFeatures[4]
        len = self.tileLength
        wid = self.tileWidth
        if orient == 'S':
            # OriginFeatures[5] is the YZ plane
            sketchObj.Support = self.partBody.Origin.OriginFeatures[5]
            len = self.tileWidth
            wid = self.tileLength
        sketchObj.Visibility=False

        # See https://github.com/ebrahimraeyat/Civil/blob/5d25dfd47aae8f310b9e73ab780889cfb31e278a/safe/punch/axis.py
        geoList = []
        # Create line segments
        # Height = 2mm
        # Width = 4mm
        # Length = tileLength - 18
        xorg=-wid/2
        yorg=0
        p1=App.Vector(xorg  ,yorg  ,0)
        p2=App.Vector(xorg  ,yorg+2,0)
        p3=App.Vector(xorg+2,yorg+2,0)
        p4=App.Vector(xorg+2,yorg  ,0)
        if orient == 'W':
            p3=App.Vector(xorg-2,2,0)
            p4=App.Vector(xorg-2,0,0)
        if orient == 'U':
            xorg=-wid/2-4
            yorg=4
            p1=App.Vector(xorg  ,yorg  ,0)
            p2=App.Vector(xorg+2,yorg  ,0)
            p3=App.Vector(xorg+2,yorg+2,0)
            p4=App.Vector(xorg  ,yorg+2,0)

        geoList.append(Part.LineSegment(p1,p2))
        geoList.append(Part.LineSegment(p2,p3))
        geoList.append(Part.LineSegment(p3,p4))
        geoList.append(Part.LineSegment(p4,p1))
        sketchObj.addGeometry(geoList,False)

        # Constraints
        conList = []

        #Sketcher.Constraint('Coincident',LineFixed,PointOfLineFixed,LineMoving,PointOfLineMoving)
        conList.append(Sketcher.Constraint('Coincident',0,2,1,1))
        conList.append(Sketcher.Constraint('Coincident',1,2,2,1))
        conList.append(Sketcher.Constraint('Coincident',2,2,3,1))
        conList.append(Sketcher.Constraint('Coincident',3,2,0,1))
#         conList.append(Sketcher.Constraint('DistanceX',1,1,1,2,2.000000))
#         conList.append(Sketcher.Constraint('DistanceY',2,2,2,1,2.000000))
        if orient=='U':
            conList.append(Sketcher.Constraint('Horizontal',0))
            conList.append(Sketcher.Constraint('Vertical',1))
            conList.append(Sketcher.Constraint('Horizontal',2))
            conList.append(Sketcher.Constraint('Vertical',3))
            conList.append(Sketcher.Constraint('DistanceX',0,1,0,2,2.0))
            conList.append(Sketcher.Constraint('DistanceY',1,1,1,2,2.000000))
        else:
            conList.append(Sketcher.Constraint('Vertical',0))
            conList.append(Sketcher.Constraint('Horizontal',1))
            conList.append(Sketcher.Constraint('Vertical',2))
            conList.append(Sketcher.Constraint('Horizontal',3))
        sketchObj.addConstraint(conList)

        ## Pad(key=True) or Pocket(slot)
        if key:
            pocket = self.partBody.newObject('PartDesign::Pad', name+'_obj')
        else:
            pocket = self.partBody.newObject('PartDesign::Pocket', name+'_obj')
        pocket.Profile = sketchObj

        pocket.Length = len - 18
        pocket.Reversed = 0
        pocket.Midplane = 1
        pocket.Visibility=True
        self.partBody.removeObject(pocket)
        self.partBody.insertObject(pocket, afterObj, True)
        return pocket, sketchObj

    '''
    Latch 
    '''
    def createObject_Latch(self, name, afterObj, orient):
        ## Create new sketch
        sketchObj = App.ActiveDocument.addObject("Sketcher::SketchObject", name + "_skt")
        self.partBody.insertObject(sketchObj, afterObj, True)
        sketchObj.MapMode='FlatFace'
        # OriginFeatures[4] is the XZ plane
        sketchObj.Support = self.partBody.Origin.OriginFeatures[4]
        len = self.tileLength
        wid = self.tileWidth
        if orient != 'E':
            # OriginFeatures[5] is the YZ plane
            sketchObj.Support = self.partBody.Origin.OriginFeatures[5]
            len = self.tileWidth
            wid = self.tileLength
        sketchObj.Visibility=False

        # See https://github.com/ebrahimraeyat/Civil/blob/5d25dfd47aae8f310b9e73ab780889cfb31e278a/safe/punch/axis.py
        geoList = []
        # Create line segments
        # Length = tileLength - 12
        # Describe a 4 sided object with vertices a,b,c,d
        # d <- c
        # a -> b /\
        xwid = 0.6              # Width = 0.6 mm
        y1 = 0.5                # Height = 0.5 mm or
        y2 = 0.8                # Height = 0.8 mm
        xorg = wid/2 - slotDepth    # Start for x
        p1=App.Vector(xorg     , 0.0, 0.0)
        p2=App.Vector(xorg+xwid, 0.0, 0.0)
        p3=App.Vector(xorg+xwid,  y1, 0.0)
        p4=App.Vector(xorg     ,  y2, 0.0)
        geoList.append(Part.LineSegment(p1,p2))
        geoList.append(Part.LineSegment(p2,p3))
        geoList.append(Part.LineSegment(p3,p4))
        geoList.append(Part.LineSegment(p4,p1))
        sketchObj.addGeometry(geoList,False)

        # Constraints
        conList = []

        #Sketcher.Constraint('Coincident',LineFixed,PointOfLineFixed,LineMoving,PointOfLineMoving)
        conList.append(Sketcher.Constraint('Coincident',0,2,1,1))
        conList.append(Sketcher.Constraint('Coincident',1,2,2,1))
        conList.append(Sketcher.Constraint('Coincident',2,2,3,1))
        conList.append(Sketcher.Constraint('Coincident',3,2,0,1))
        conList.append(Sketcher.Constraint('Horizontal',0))
        conList.append(Sketcher.Constraint('Vertical',1))
        conList.append(Sketcher.Constraint('Vertical',3))
        conList.append(Sketcher.Constraint('DistanceX',0,1,0,2,xwid))
        conList.append(Sketcher.Constraint('DistanceY',1,1,1,2,y1))
        conList.append(Sketcher.Constraint('DistanceY',3,2,3,1,y2))

        sketchObj.addConstraint(conList)

        # Latch object (Pad)
        newObj = self.partBody.newObject('PartDesign::Pad', name+'_obj')
        newObj.Profile = sketchObj

        newObj.Length = len - 12
        newObj.Reversed = 0
        newObj.Midplane = 1
        newObj.Visibility=True
        # Insert in the correct place
        self.partBody.removeObject(newObj)
        self.partBody.insertObject(newObj, afterObj, True)
        return newObj, sketchObj

    '''
    Latch notch, accepts the latch and locks.
    '''
    def createObject_LatchNotch(self, name, afterObj, orient):
        ## Create new sketch
        sketchObj = App.ActiveDocument.addObject("Sketcher::SketchObject", name + "_skt")
        self.partBody.insertObject(sketchObj, afterObj, True)
        sketchObj.MapMode='FlatFace'
        # OriginFeatures[4] is the XZ plane
        sketchObj.Support = self.partBody.Origin.OriginFeatures[4]
        sketchObj.Visibility=False
        len = self.tileLength
        wid = self.tileWidth

        # Snip shape
        xwid = 0.7
        xorg = -wid/2+5
        y1=0.9
        y2=0.55
        if orient == 'W':
            xorg = -wid/2-5
            xwid = -0.7
        p1=App.Vector(xorg     , y1 ,0)
        p2=App.Vector(xorg-xwid, y2,0)
        p3=App.Vector(xorg-xwid, 0.0 ,0)
        p4=App.Vector(xorg     , 0.0 ,0)
        if orient == 'U':
            xorg = xorg-9
            p1=App.Vector(xorg+y1, 10,0)
            p2=App.Vector(xorg+y2,  8,0)
            p3=App.Vector(xorg   ,  8,0)
            p4=App.Vector(xorg   , 10,0)
        geoList = []
        geoList.append(Part.LineSegment(p1,p2))
        geoList.append(Part.LineSegment(p2,p3))
        geoList.append(Part.LineSegment(p3,p4))
        geoList.append(Part.LineSegment(p4,p1))
        sketchObj.addGeometry(geoList,False)

        # Constraints
        conList = []

        #Sketcher.Constraint('Coincident',LineFixed,PointOfLineFixed,LineMoving,PointOfLineMoving)
        conList.append(Sketcher.Constraint('Coincident',0,2,1,1))
        conList.append(Sketcher.Constraint('Coincident',1,2,2,1))
        conList.append(Sketcher.Constraint('Coincident',2,2,3,1))
        conList.append(Sketcher.Constraint('Coincident',3,2,0,1))
        if orient != 'U':
            conList.append(Sketcher.Constraint('Vertical',1))
            conList.append(Sketcher.Constraint('Horizontal',2))
            conList.append(Sketcher.Constraint('Vertical',3))
            conList.append(Sketcher.Constraint('DistanceY',1,2,1,1,y2))
            conList.append(Sketcher.Constraint('DistanceX',2,1,2,2,xwid))
            conList.append(Sketcher.Constraint('DistanceY',3,1,3,2,y1))
        sketchObj.addConstraint(conList)

        # Notch (pocket)
        newObj = self.partBody.newObject('PartDesign::Pocket', name+'_obj')
        newObj.Profile = sketchObj

        newObj.Length = len
        newObj.Reversed = 0
        newObj.Midplane = 1
        newObj.Visibility=False
        # Insert in the correct place
        self.partBody.removeObject(newObj)
        self.partBody.insertObject(newObj, afterObj, True)
        return newObj, sketchObj
    '''
    Create connector latch then a polar array from the connector.
    '''
    def createObject_ConnectorLatchArray(self, name, afterObj, sketchObj, connectorArray, latchArray):
        multiTransform = self.partBody.newObject('PartDesign::MultiTransform', name)
        multiTransform.Originals = [connectorArray, latchArray,]

        polar = self.partBody.newObject('PartDesign::PolarPattern',name+'_PolarPattern')
        polar.Axis = (sketchObj,['V_Axis'])
        polar.Angle = 360
        polar.Occurrences = 2
        polar.Visibility = False

        multiTransform.Transformations = [polar]
        self.partBody.removeObject(multiTransform)
        self.partBody.insertObject(multiTransform, afterObj, True)
        # Insert in the correct place
        self.partBody.removeObject(multiTransform)
        self.partBody.insertObject(multiTransform, afterObj, True)
        
        return multiTransform

    '''
    Bracket supports the 90deg   
    '''
    def createObject_BracketBacker(self, name, afterObj, orient):
        sketchObj = App.ActiveDocument.addObject("Sketcher::SketchObject", name+"_skt")
        self.partBody.insertObject(sketchObj, afterObj, True)
        sketchObj.MapMode='FlatFace'
        # OriginFeatures[4] is the XZ plane
        sketchObj.Support = self.partBody.Origin.OriginFeatures[4]
        len = self.tileLength
        wid = self.tileWidth
        geoList = []
        # A drawing in 8 points!
        p1=App.Vector(-wid/2-5  , 9.5,0)
        p2=App.Vector(-wid/2-4  , 9.5,0)
        p3=App.Vector(-wid/2-4  , 4,0)
        p4=App.Vector(-wid/2    , 4,0)
        p5=App.Vector(-wid/2    , 0,0)
        p6=App.Vector(-wid/2+5.5, 0,0)
        p7=App.Vector(-wid/2+5.5,-1,0)
        p8=App.Vector(-wid/2-5  ,-1,0)
        geoList.append(Part.LineSegment(p1,p2))
        geoList.append(Part.LineSegment(p2,p3))
        geoList.append(Part.LineSegment(p3,p4))
        geoList.append(Part.LineSegment(p4,p5))
        geoList.append(Part.LineSegment(p5,p6))
        geoList.append(Part.LineSegment(p6,p7))
        geoList.append(Part.LineSegment(p7,p8))
        geoList.append(Part.LineSegment(p8,p1))
        sketchObj.addGeometry(geoList,False)
        sketchObj.Visibility = False

        # Constraints
        conList = []

        #Sketcher.Constraint('Coincident',LineFixed,PointOfLineFixed,LineMoving,PointOfLineMoving)
        conList.append(Sketcher.Constraint('Coincident',0,2,1,1))
        conList.append(Sketcher.Constraint('Coincident',1,2,2,1))
        conList.append(Sketcher.Constraint('Coincident',2,2,3,1))
        conList.append(Sketcher.Constraint('Coincident',3,2,4,1))
        conList.append(Sketcher.Constraint('Coincident',4,2,5,1))
        conList.append(Sketcher.Constraint('Coincident',5,2,6,1))
        conList.append(Sketcher.Constraint('Coincident',6,2,7,1))
        conList.append(Sketcher.Constraint('Coincident',7,2,0,1))
        #
        conList.append(Sketcher.Constraint('DistanceX',6,2,6,1,10.500000))
        conList.append(Sketcher.Constraint('DistanceY',7,1,7,2,10.500000))
        conList.append(Sketcher.Constraint('DistanceX',2,1,2,2,4.000000))
        conList.append(Sketcher.Constraint('DistanceY',3,2,3,1,4.000000)) 
        conList.append(Sketcher.Constraint('DistanceY',1,2,1,1,5.500000))
        conList.append(Sketcher.Constraint('DistanceX',4,1,4,2,5.500000))
        #
        conList.append(Sketcher.Constraint('Horizontal',0))
        conList.append(Sketcher.Constraint('Vertical',1))
        conList.append(Sketcher.Constraint('Horizontal',2))
        conList.append(Sketcher.Constraint('Vertical',3))
        conList.append(Sketcher.Constraint('Horizontal',4))
        conList.append(Sketcher.Constraint('Vertical',5))
        conList.append(Sketcher.Constraint('Horizontal',6))
        conList.append(Sketcher.Constraint('Vertical',7))
        sketchObj.addConstraint(conList)
        #
        pad = self.partBody.newObject('PartDesign::Pad', name+'_obj')
        pad.Profile = sketchObj


        if self.extendedEdge:
            len -=0.1
        else:
            len -=10
        pad.Length = len
        pad.Midplane = 1
        pad.Visibility = True
        self.partBody.removeObject(pad)
        self.partBody.insertObject(pad, afterObj, True)
        return pad, sketchObj

    '''
    Hinge body. Accepts pin.
    Contains pivot point.
    '''
    def createObject_HingeBody(self, name, afterObj, orient):
        sketchObj = App.ActiveDocument.addObject("Sketcher::SketchObject", name+"_skt")
        self.partBody.insertObject(sketchObj, afterObj, True)
        sketchObj.MapMode='FlatFace'
        sketchObj.Visibility = False

        # OriginFeatures[4] is the XZ plane
        sketchObj.Support = self.partBody.Origin.OriginFeatures[4]
        len = self.tileLength
        wid = self.tileWidth
        geoList = []
        # A drawing in 8 points!
        p1=App.Vector(-wid/2-4  , 4.0,0)
        p2=App.Vector(-wid/2    , 4.0,0)
        p3=App.Vector(-wid/2    , 0.0,0)
        p4=App.Vector(-wid/2+5  , 0.0,0)
        p5=App.Vector(-wid/2+5  ,-1.0,0)
        p6=App.Vector(-wid/2-4  ,-1.0,0)

        geoList.append(Part.LineSegment(p1,p2))
        geoList.append(Part.LineSegment(p2,p3))
        geoList.append(Part.LineSegment(p3,p4))
        geoList.append(Part.LineSegment(p4,p5))
        geoList.append(Part.LineSegment(p5,p6))
        geoList.append(Part.LineSegment(p6,p1))
        sketchObj.addGeometry(geoList,False)

        conList = []
        #Sketcher.Constraint('Coincident',LineFixed,PointOfLineFixed,LineMoving,PointOfLineMoving)
        conList.append(Sketcher.Constraint('Coincident',0,2,1,1))
        conList.append(Sketcher.Constraint('Coincident',1,2,2,1))
        conList.append(Sketcher.Constraint('Coincident',2,2,3,1))
        conList.append(Sketcher.Constraint('Coincident',3,2,4,1))
        conList.append(Sketcher.Constraint('Coincident',4,2,5,1))
        conList.append(Sketcher.Constraint('Coincident',5,2,0,1))
        conList.append(Sketcher.Constraint('DistanceX',1,2,-1,1,wid/2))
        conList.append(Sketcher.Constraint('DistanceX',0,1,0,2,4.000000))
        conList.append(Sketcher.Constraint('DistanceX',4,2,4,1,9.000000))
        conList.append(Sketcher.Constraint('DistanceY',1,2,1,1,4.000000))
        conList.append(Sketcher.Constraint('DistanceY',5,1,5,2,5.000000))
        conList.append(Sketcher.Constraint('DistanceY',-1,1,2,2,0.000000))
        conList.append(Sketcher.Constraint('Horizontal',0))
        conList.append(Sketcher.Constraint('Horizontal',2))
        conList.append(Sketcher.Constraint('Horizontal',4))
        conList.append(Sketcher.Constraint('Vertical',1))
        conList.append(Sketcher.Constraint('Vertical',3))
        conList.append(Sketcher.Constraint('Vertical',5))
        sketchObj.addConstraint(conList)

        # Add hinge pin hole
        radius=1.92/2
        Xvar=-wid/2-2
        Yvar=2
        sketchObj.addGeometry(Part.Circle(App.Vector(Xvar,Yvar,0),App.Vector(0,0,1),radius),False)
        sketchObj.addConstraint(Sketcher.Constraint('DistanceY',6,3,0,2,2.0))
        sketchObj.addConstraint(Sketcher.Constraint('DistanceX',6,3,0,2,2.0))
        sketchObj.addConstraint(Sketcher.Constraint('Radius',6,radius))

        # 
        # TODO Compute X & Y vector values
#         sketchObj.fillet(3,4,App.Vector(-15.0,-0.5,0),App.Vector(-16.0,-1.0,0),0.5,True,True)
#         sketchObj.addConstraint(Sketcher.Constraint('Radius',7,0.500000))
#         sketchObj.fillet(4,5,App.Vector(-23.5,-1.0,0),App.Vector(-24.0,-0.5,0),0.5,True,True)
#         sketchObj.addConstraint(Sketcher.Constraint('Radius',9,0.500000))
#         sketchObj.fillet(5,0,App.Vector(-24.0,3,0),App.Vector(-23.5,4,0),2.0,True,True)
#         sketchObj.addConstraint(Sketcher.Constraint('Radius',11,2.0))

        # Object
        pad = self.partBody.newObject('PartDesign::Pad',name+'_obj')
        pad.Profile = sketchObj

        # len = tileWidth - (extendedEdge==True? 0.2 : 10)
        if self.extendedEdge:
            len -=0.2
        else:
            len -=10
        pad.Length = len
        pad.Midplane = 1
        pad.Visibility = True
        self.partBody.removeObject(pad)
        self.partBody.insertObject(pad, afterObj, True)
        return pad, sketchObj

    '''
    Hinge mating cut and array
    '''
    def createObject_HingeMateCut(self, name, afterObj, orient):
        sketchObj = App.ActiveDocument.addObject("Sketcher::SketchObject", name+"_skt")
        self.partBody.insertObject(sketchObj, afterObj, True)
        sketchObj.MapMode='FlatFace'
        sketchObj.Visibility = False

        # OriginFeatures[4] is the XZ plane
        sketchObj.Support = self.partBody.Origin.OriginFeatures[4]
        len = self.tileLength
        wid = self.tileWidth
        geoList = []

        # Snip shape
        p1=App.Vector(-wid/2-4  , 4.0,0)
        p2=App.Vector(-wid/2    , 4.0,0)
        p3=App.Vector(-wid/2    ,-1.0,0)
        p4=App.Vector(-wid/2-4  ,-1.0,0)

        geoList.append(Part.LineSegment(p1,p2))
        geoList.append(Part.LineSegment(p2,p3))
        geoList.append(Part.LineSegment(p3,p4))
        geoList.append(Part.LineSegment(p4,p1))
        sketchObj.addGeometry(geoList,False)

        # Constraints
        conList = []

        #Sketcher.Constraint('Coincident',LineFixed,PointOfLineFixed,LineMoving,PointOfLineMoving)
        conList.append(Sketcher.Constraint('Coincident',0,2,1,1))
        conList.append(Sketcher.Constraint('Coincident',1,2,2,1))
        conList.append(Sketcher.Constraint('Coincident',2,2,3,1))
        conList.append(Sketcher.Constraint('Coincident',3,2,0,1))
        conList.append(Sketcher.Constraint('Horizontal',0))
        conList.append(Sketcher.Constraint('Vertical',1)) 
        conList.append(Sketcher.Constraint('Horizontal',2))
        conList.append(Sketcher.Constraint('Vertical',3))
        conList.append(Sketcher.Constraint('DistanceX',0,1,0,2,4.000000))
        conList.append(Sketcher.Constraint('DistanceY',3,1,3,2,5.000000)) 
        sketchObj.addConstraint(conList)

        # Object
        newObj = self.partBody.newObject('PartDesign::Pocket',name+'_obj')
        newObj.Profile = sketchObj
        # TODO Save cut
        newObj.Length = 5.30
        newObj.Midplane = 0
        newObj.Visibility = False
        self.partBody.removeObject(newObj)
        self.partBody.insertObject(newObj, afterObj, True)

        # Array
        multiTransform = self.partBody.newObject('PartDesign::MultiTransform', name+'_array')
        multiTransform.Originals = [newObj,]
        holePatV = self.partBody.newObject('PartDesign::LinearPattern',name+'_LinearPattern')
        holePatV.Direction = (sketchObj,['N_Axis'])
        holePatV.Length = self.tileWidth-10
        holePatV.Occurrences = self.unitWidth
        holePatV.Reversed = 0

        multiTransform.Transformations = [holePatV]
        self.partBody.removeObject(multiTransform)
        self.partBody.insertObject(multiTransform, newObj, True)
        
        return multiTransform, sketchObj

    '''
    Latch 
    '''
    def refreshScreen(self, lastObj):
        App.activeDocument().recompute()
        Gui.Selection.clearSelection()
        lastObj.Visibility=True
        Gui.Selection.addSelection(lastObj)
        Gui.Selection.clearSelection()
        Gui.activeDocument().activeView().viewIsometric()
        Gui.SendMsgToActiveView("ViewFit")

    '''
    Part: Tile
    '''
    def doTile(self):
        self.createOrGetDoc(docName)
        self.createPart(tileName+"_"+str(self.unitWidth)+"x"+str(self.unitLength))
        thw=self.tileWidth/2
        thl=self.tileLength/2

        # Create Body and tile object
        self.createObject_Tile('tile_base')
        # Object: Mount Hole
        (pocket, sketchObj) = self.createObject_MountHole("tile_mount_hole")
        # Object: Mount Hole Array
        lastObj = self.createObject_MountHoleArray('tile_mount_array', pocket, sketchObj)

        # V E R T I C A L
        # Object: Vert, East facing slot
        (pocket, sketchObj) = self.createObject_SlotKey("tile_vert_slot", lastObj,-thw,-thl+10,'E', False)
        list = []
        list.append(pocket)
        # Object: Vert Slot and Polar Array
        lastObj = self.createObject_SlotKeyArrayPolar('tile_vert_slot_array', pocket, list, sketchObj,'E')
        # Object: Vert Slot Connector
        (connectorArray, sketchObj) = self.createObject_Connector('tile_vspine_slot', lastObj, 'E', False)
        # Object: Vert Latch
        (latchArray, sketchObj) = self.createObject_Latch('tile_vert_latch', connectorArray, 'E')
        # Object: Vert Slot Connector and Latch Polar Array
        lastObj = self.createObject_ConnectorLatchArray('tile_vert_latch array', latchArray, sketchObj, connectorArray, latchArray)
 
        # H O R I Z O N T A L
        # Object: Horz, South facing Slot
        (pocket, sketchObj) = self.createObject_SlotKey("tile_horz_slot", lastObj,-thw+10,-thl,'S', False)
        list = []
        list.append(pocket)
        # Object: Horz Slot and Polar Array
        lastObj = self.createObject_SlotKeyArrayPolar('tile_horz_slot_array', pocket, list, sketchObj,'S')
        # Object: Horz Slot Connector
        (connectorArray, sketchObj) = self.createObject_Connector('tile_hspine_slot', lastObj, 'S', False)
        # Object: Horz Latch
        (latchArray, sketchObj) = self.createObject_Latch('tile_horz_latch', connectorArray, 'S')
        # Object: Vert Slot Connector and Latch Polar Array
        lastObj = self.createObject_ConnectorLatchArray('tile_horz_latch_array', latchArray, sketchObj, connectorArray, latchArray)
 
        # REFRESH SCREEN!
        self.refreshScreen(lastObj)

    '''
    Part: Connector
    '''
    def doConnector(self):
        self.createOrGetDoc(docName)
        partName = self.createPart("connector"+"_"+str(self.unitLength)+"x")
        thw=self.tileWidth/2
        thl=self.tileLength/2

        # Reset LCS
        self.lcs.AttachmentOffset = App.Placement(App.Vector(-thw,0,0),App.Rotation(App.Vector(0,0,1),0))

        lastObj=None
        #####
        # Side 1
        #####
        # Obj: Key spine rspine
        (lastObj, sketchObj) = self.createObject_Connector('rspine', lastObj, 'E', True)
        # Obj: Key rspine
        (lastObj, sketchObj) = self.createObject_SlotKey("rspine_key", lastObj,-thw,-thl+10,'E', True)
        rspine_key_skt = sketchObj
        list=[]
        list.append(lastObj)

        # Obj: Key Array
        lastObj = self.createObject_SlotKeyArray('rspine_key_array', lastObj, list, rspine_key_skt,'E')
        # Obj: Latch Notch
        (lastObj, sketchObj) = self.createObject_LatchNotch('rspine_latch_notch', lastObj, 'E')

        #####
        # Side 2
        #####
        # Obj: Key Connector
        (lastObj, sketchObj) = self.createObject_Connector('lspine', lastObj, 'W', True)
        # Obj: Key
        (lastObj, sketchObj) = self.createObject_SlotKey("lspine_key", lastObj,-thw,-thl+10,'W', True)
        lspine_key_skt = sketchObj
        list=[]
        list.append(lastObj)

        # Obj: Key Array
        lastObj = self.createObject_SlotKeyArray('lspine_key_array', lastObj, list, lspine_key_skt,'W')
        # Obj: Latch Notch
        (lastObj, sketchObj) = self.createObject_LatchNotch('lspine_latch_notch', lastObj, 'W')

        # REFRESH SCREEN!
        self.refreshScreen(lastObj)

    '''
    Part: Bracket
    '''
    def doBracket(self):
        self.createOrGetDoc(docName)
        partName = self.createPart("bracket"+"_"+str(self.unitLength)+"x")
        thw=self.tileWidth/2
        thl=self.tileLength/2

        # Reset LCS
        self.lcs.AttachmentOffset = App.Placement(App.Vector(-thw,0,0),App.Rotation(App.Vector(0,0,1),0))

        lastObj=None
        # Side 1
        # Obj: Key Spine
        (connector, sketchObj) = self.createObject_Connector('bracket_lwr_spine', lastObj, 'E', True)
        lastObj=connector
        # Obj: Key
        (lastObj, sketchObj) = self.createObject_SlotKey("bracket_lwr_key", lastObj,-thw,-thl+10,'E', True)
        list=[]
        list.append(lastObj)
        # Obj: Key Array
        lastObj = self.createObject_SlotKeyArray('bracket_lwr_key_array', lastObj, list, sketchObj,'E')
        # Obj: Latch Notch
        (lastObj, sketchObj) = self.createObject_LatchNotch('bracket_lwr_latch_notch', lastObj, 'E')

        (lastObj, sketchObj) = self.createObject_BracketBacker("bracket_backer", lastObj, 'E')

        # Side 2
        # Obj: Key Connector
        (lastObj, sketchObj) = self.createObject_Connector('bracket_bk_spine', lastObj, 'U', True)
        # Obj: Key
        (lastObj, sketchObj) = self.createObject_SlotKey("bracket_bk_key", lastObj,-thl+10, 4, 'U', True)
#         sketchObj.AttachmentOffset = App.Placement(App.Vector(0,0,-thw-4),App.Rotation(App.Vector(0,0,1),0))
        list=[]
        list.append(lastObj)
        # Obj: Key Array
        lastObj = self.createObject_SlotKeyArray('bracket_bk_key_array', lastObj, list, sketchObj,'U')
        # Obj: Latch Notch
        (lastObj, sketchObj) = self.createObject_LatchNotch('bracket_bk_latch_notch', lastObj, 'U')
 
        # REFRESH SCREEN!
        self.refreshScreen(lastObj)


    '''
    Part: Hinge
    '''
    def doHinge(self):
        self.createOrGetDoc(docName)
        partName = self.createPart("hinge"+"_"+str(self.unitLength)+"x")
        thw=self.tileWidth/2
        thl=self.tileLength/2

        # Reset LCS
        self.lcs.AttachmentOffset = App.Placement(App.Vector(-thw,0,0),App.Rotation(App.Vector(0,0,1),0))

        lastObj=None
        # Key & spine
        # Object: Key Spine
        (lastObj, sketchObj) = self.createObject_Connector('hinge_key_spine', lastObj, 'E', True)
        # Object: Key
        (lastObj, sketchObj) = self.createObject_SlotKey("hinge_key", lastObj,-thw,-thl+10,'E', True)
        hingeKeySkt=sketchObj
        list=[]
        list.append(lastObj)

        # Object: Key Array
        lastObj = self.createObject_SlotKeyArray('hinge_key_array', lastObj, list, hingeKeySkt,'E')

        # Object: Hinge frame
        (lastObj, sketchObj) = self.createObject_HingeBody('hinge_frame', lastObj, 'E')
        # Obj: Mate cut (pocket) and array
        (lastObj, sketchObj) = self.createObject_HingeMateCut('hinge_mate_cut', lastObj, 'E')
        # Obj: Latch Notch
        (lastObj, sketchObj) = self.createObject_LatchNotch('hinge_latch_notch', lastObj, 'E')
        # REFRESH SCREEN!
        self.refreshScreen(lastObj)

### END OF CLASS tile ###

#
# Create Tile Object
#

#X TODO: Finish basic implementation
#X TODO: Add lcs to tile for assembly
#X TODO: Add dimensional constraints
#X TODO: Add fillet to slot and key [createObject_SlotKey()] corners.
#X TODO: Query user for dimensions

## TODO: Add fillet to key [createObject_SlotKey()] top hinge edges.
## TODO: Add fillet to key [createObject_SlotKey()] top bracket edges.
## TODO: Add fillet to key [createObject_SlotKey()] top connector edges.
## TODO: Curve notch.
## TODO: Bracket - fix upper latch notch dimensions
## TODO: Add lcs to bracket, hinge and connector for assembly
## TODO: Add positional constraints
## TODO: Test build

x=operateUI()

# x=Ui_Dialog()
# x.showPlane()

# Instantiate tile object
# _tile = tile()
# Model a tile
# _tile.doTile()
# _tile.doConnector()
# _tile.doBracket()
# _tile.doHinge()
